/*************************************************************
	Практическое занятие №3. Директивы препроцессора.
							Указатели.
*************************************************************/
#define _USE_MATH_DEFINES
#include <iostream>
#include <tchar.h>
#include <cmath>


#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку

int _tmain()
{
// ********************************************************
	//Задание 1. Директивы препроцессора

	//1.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
	int r = 3;
	double S;
	S = M_PI * r * r;
// *******************************************************


	
	//1.2.Макросы с параметрами.
	//1.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:
	{
#define LENGHT(x) (2*M_PI*(x))
		
		float l1 = LENGHT(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGHT(2); // должно быть 0.07957...
		stop
	}
// *******************************************************

	//1.2.2 (B) определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно
#define MAX(a, b) ((a)>(b) ? (a): (b))
	int i = 10, j = 12, k;
	k = MAX(i, j);
	k = MAX(j, i) * 2;
	k = MAX(j, i+3);
	k = MAX(i--, j++); // инкрементируются несколько раз по тексту

// *******************************************************

	//1.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	
#define EXCHANGE(x, y) x=(x)+(y); y=(x)-(y); x=(x)-(y)
	int x1=1, y1=-1;
	EXCHANGE(x1,y1);

	int x2=100, y2=-100;
	EXCHANGE(x2,y2);


// *******************************************************


	//1.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?

int iNN;

#if defined NNN && defined MMM
	iNN = 0;    // #define NNN   #define MMM
#elif defined MMM
	iNN = 1;   // #define MMM
#elif defined NNN 
	iNN = 2;   // #define NNN

#else
	iNN = -1;
#endif
	
	stop

	
// *******************************************************

	//Задание 1.4. Загляните в Project -> Properties -> диалоговая панель
	//- Property Pages -> C\C++  -> Preprocessor -> Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.
#ifdef _DEBUG 
		std::cout<< __FILE__ << ' ' << __LINE__ << ' ' << __TIME__ << std::endl;
#endif
	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"
#ifdef NDEBUG 
	std::cout << "Release configuration!" << std::endl;
#endif
	//Подсказка: для получения нужной информации зайдите в online справку
	//(Help -> View Help), выберете язык C++ и в поле поиска введите 
	//следующую ключевую фразу: Predefined Macros
	
	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build-> Configuration Manager -> Configuration




// *******************************************************
	{
		//Задание 1.5  Управляя определенностью идентификатора _UNICODE и используя
		//возможности заголовочного <tchar.h>, определим и проинициализируем переменную,
		//которая может становиться как однобайтовой, так и расширенной без 
		//изменения исходного текста.
		//С помощью отладчика проверьте результат (определите значение в 10-чной и 16-чной системе счисления).

	//Подсказка: Для того, чтобы настроить проект на работу с  некоторой кодировкой, надо:
		//1)Выбрать Project -> Properties. Будет открыта диалоговая панель  Property Pages  
		//2)Configuration Properties -> Advansed-> Advansed Properties -> Character Set
		//3) установить флаг "Use Unicode Character Set", если требуется Unicode
		//4) установить флаг "Not Set", если требуется  работа с однобайторфми символами.
		TCHAR ch1 = __T('A');	// ch1=65   0x0041
		size_t s1 = sizeof(ch1);// s1=2     0x00000002       1
		TCHAR ch2 = __T('Ф');	// ch2=1060 0x0424           -44    0xd4 'Ф'
		TCHAR ch3 = 'Ф';	// ch3=65492    0xffd4			-44		0xd4 'Ф'
		stop
	}
// ********************************************************
	//Задание 2.Заголовочные файлы. Директива #include
	//Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h
#ifdef _DEBUG 
#include "1.h"
#endif
#ifdef NDEBUG 
#include "2.h"
#endif

// ********************************************************

	//Задание 3. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
	int a = 14;
	char b = 2;
	double c = 3.2;
	int* pa = &a;
	char* pb = &b;
	double* pc = &c;

// *******************************************************

	//Задание 3а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
	
	const char *ptext = "abcd";
	char text = 'b';
	//*ptext = text; указатель на строку - константа

	stop
	
// *******************************************************

	//Задание 4. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3}; // массив из трех элементов
		int* pn = &nAr[0];  // указатель нулевого элемента
		(*pn)++;	// +1 к элементу массива
		pn++;	// +1 к указателю

		char cAr[]={'A','B','C','D'};
		char* pc = &cAr[0];
		(*pc)=(*pc)+5;	//+5 к элементу
		pc=pc+3;	//+3 к указателю
	
		double dAr[3]={1.0,2.0};
		double* pd1 = &dAr[0];  //указатель на нулевой элемент
		double* pd2 = pd1; //указатель на указатель на элемент
		(*pd2)+=2; //+2 к элементу
		pd2+=2; // +2 к указателю

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1; // разница в 1 элемент в памяти

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		if (pd1 > pd2) {
			std::cout << pd1 << std::endl;
		} else { std::cout << pd2 << std::endl; }
		stop
	}


// *******************************************************
/*
	//Задание 5. Void-указатель. 
	//5.1. Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	
	pVoid=&nObject3;
	pVoid=&cObject3;
	pVoid=pInt;
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
//	pInt=pVoid;

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		//... = &n;//????объявить слева void-указатель
	}
// *******************************************************

	//5.2. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) 
	stop
*/
// *******************************************************

/*
	//Задание 6.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям
	int	n1=1;

    //Объявите указатель pn и проинициализируйте его так, чтобы он
	//"указывал" на n1


    //Объявите указатель ppn и проинициализируйте его так, чтобы он
	//"указывал" на pn


    //Объявите указатель pppn и проинициализируйте его так, чтобы он
	//"указывал" на ppn

  
	//С помощью указателей pn, ppn и ppn получите значение объекта n1
	//и присвойте его n2

	//int n2=...

  
	stop
*/



	return 0;
}//end main
